/* ----------------------------------------------
		a^(2^n) alakú szavak
*/

// legbal levezetés
#pragma leftmost
start S;
nterm Z;
term a;

/* A programozott nyelvtan matematikai definíciója szerint
 egy levezetésben az elsõ végrehajtott szabály 
 tetszõleges lehet. A Prolanban viszont az elsõ végrehajtott
 szabály mindig az elsõ utasítás (ez megfelel annak,
 amit egy imperatív programtól elvárunk). A definíció szerinti
 mûködést az alábbi f1, f2, f3 nemdeterminisztikus 
 ugrással lehet szimulálni.
*/
void pelda1()
{
	f1, f2, f3;
	f1: if (S = Z Z)	f1; 	else f2;
	f2: if (Z = S)		f2; 	else f1, f3;
	f3: if (S = a)		f3;	else exit;
}

/* ----------------------------------------------
	   ugyanaz egyszerûbben

some A; jelentése: néhányszor végrehajtja A-t
	(esetleg egyszer sem)
	
all E; jelentése:
   Addig folytatja E kiértékelését, amíg annak értéke igaz.
   Pl. all S = a; minden S-t a-ra cserél. */
void pelda2()
{
	some { all S = Z Z; all Z = S; }
	all S = a;
}


/* ----------------------------------------------
	   (majdnem) ugyanaz
		
[ S1; S2; ... Sn; ] jelentése: végtelen ciklus
   Véletlenszerûen választ egy Si utasítást, azt végrehajtja.
   Újra választ addig, amíg nem terminál.
*/

void pelda3()
[
	{ all S = Z Z; all Z = S; }
	all S = a;
]

void main()
{
// Hívja meg a kívánt makrót, a többit kommentezze ki:
	pelda1();
	//pelda2();
	//pelda3();
}